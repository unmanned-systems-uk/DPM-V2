# Claude Code - READ THIS FIRST
## DPM Payload Manager Project Rules & Workflow

**Date Created:** October 25, 2025
**Last Updated:** October 30, 2025
**Version:** 2.5 (Platform Identification & START Command)
**Status:** üî¥ **MANDATORY - READ EVERY SESSION**

---

## ‚ö° QUICK START COMMAND

**Type `START` at the beginning of any session for automatic setup!**

When you type **START**, Claude Code will automatically:

1. ‚úÖ Ask which platform you're working on (Air/Ground/WindowsTools/Docs)
2. ‚úÖ Confirm current Git branch (should be `main`)
3. ‚úÖ Run `git pull origin main` and check for conflicts
4. ‚úÖ Verify protocol files are at correct location (`~/DPM-V2/protocol/`)
5. ‚úÖ Check protocol synchronization (commands.json & camera_properties.json)
6. ‚úÖ Read the appropriate PROGRESS_AND_TODO.md
7. ‚úÖ Run `git status` and show uncommitted changes
8. ‚úÖ Identify current phase and next recommended task
9. ‚úÖ Ready to work!

**Example:**
```
User: START
Claude: 
  üéØ Which platform are you working on?
  1. üîπ AIR-SIDE (C++ SBC in sbc/)
  2. üîπ GROUND-SIDE (Android in android/)
  3. üîπ WINDOWSTOOLS (Python Diagnostic in WindowsTools/)
  4. üîπ DOCS (Protocol/Documentation)
  
User: 1
Claude: 
  ‚úÖ Air-Side mode activated
  ‚úÖ Confirming branch: main
  ‚úÖ Running git pull...
  ‚úÖ Checking protocol files location...
  ‚úÖ Checking protocol sync...
  ‚úÖ Reading sbc/docs/PROGRESS_AND_TODO.md...
  [proceeds with session initialization]
```

**Alternative:** You can also specify platform directly:
- `START AIR` - Start air-side session
- `START GROUND` - Start ground-side session
- `START WINDOWS` - Start WindowsTools session
- `START DOCS` - Start documentation session

---

## üéØ PLATFORM IDENTIFICATION (MANDATORY!)

**üî¥ CRITICAL: Claude Code MUST ask which platform at the start of EVERY session! üî¥**

### Platform Question (Always Ask First!)

**At the start of EVERY work session, Claude Code MUST ask:**

```
üéØ Which platform are you working on today?

1. üîπ AIR-SIDE (C++ SBC)
   - Working in sbc/ directory
   - C++ development
   - Sony SDK integration
   - Raspberry Pi 4 target

2. üîπ GROUND-SIDE (Android App)
   - Working in android/ directory
   - Kotlin development
   - H16 Ground Station target

3. üîπ WINDOWSTOOLS (Python Diagnostic)
   - Working in WindowsTools/ directory
   - Python/tkinter development
   - Windows PC diagnostic tool

4. üîπ DOCS/PROTOCOL
   - Working in docs/ or protocol/ directories
   - Protocol specification
   - Cross-platform documentation

Please respond with: AIR, GROUND, WINDOWS, or DOCS
```

**Wait for user response before proceeding!**

**Once platform is identified:**
- Set context for entire session
- Apply platform-specific rules
- Read platform-specific documentation
- Use platform-specific commit prefixes

### Platform-Specific Session Paths

**If AIR-SIDE selected:**
- ‚úÖ Read Common Rules (below)
- ‚úÖ Read [Air-Side Specifics](#-air-side-specifics-c-sbc)
- ‚úÖ Check `sbc/docs/PROGRESS_AND_TODO.md`
- ‚úÖ Verify Docker status (if applicable)
- ‚úÖ Check Sony SDK availability
- ‚úÖ Bookmark Sony SDK HTML documentation
- ‚úÖ Set Git commit prefix to `[AIR]`

**If GROUND-SIDE selected:**
- ‚úÖ Read Common Rules (below)
- ‚úÖ Read [Ground-Side Specifics](#-ground-side-specifics-android-app)
- ‚úÖ Check `android/docs/PROGRESS_AND_TODO.md`
- ‚úÖ Check commented-out methods in NetworkClient.kt
- ‚úÖ Verify ADB connectivity
- ‚úÖ Set Git commit prefix to `[GROUND]`

**If WINDOWSTOOLS selected:**
- ‚úÖ Read Common Rules (below)
- ‚úÖ Read [WindowsTools Specifics](#-windowstools-specifics-python-diagnostic)
- ‚úÖ Check `WindowsTools/PROGRESS_AND_TODO.md`
- ‚úÖ Verify Python environment
- ‚úÖ Test application launch
- ‚úÖ Set Git commit prefix to `[WINDOWS]`

**If DOCS/PROTOCOL selected:**
- ‚úÖ Read Common Rules (below)
- ‚úÖ Focus on protocol synchronization
- ‚úÖ Check both air and ground implementation status
- ‚úÖ Set Git commit prefix to `[DOCS]`

---

## üî¥ CRITICAL: PROTOCOL FILE LOCATION

**BOTH Air-Side AND Ground-Side Claude Code instances MUST understand this:**

### Protocol Files Location

**‚úÖ CORRECT Location for Communal Protocol Files:**
```
~/DPM-V2/protocol/
  ‚îú‚îÄ‚îÄ camera_properties.json    ‚Üê Shared by BOTH Air-Side and Ground-Side
  ‚îú‚îÄ‚îÄ commands.json              ‚Üê Shared by BOTH Air-Side and Ground-Side
  ‚îî‚îÄ‚îÄ [other protocol specs]     ‚Üê Shared specification files
```

**‚ùå WRONG - Protocol files are NOT in docs/ folder:**
```
~/DPM-V2/docs/protocol/   ‚Üê ‚ùå OLD LOCATION - DO NOT USE
```

### Key Rules for Protocol Files

1. **üî¥ Protocol files MUST be at `~/DPM-V2/protocol/`**
   - These are RUNTIME specification files
   - NOT documentation files
   - Shared by both platforms

2. **üî¥ NEVER hard-code camera property values**
   - Air-Side C++: PropertyLoader loads from `protocol/camera_properties.json`
   - Ground-Side Android: PropertyLoader loads from `assets/camera_properties.json` (bundled copy)
   - Android must sync assets file from root protocol/ directory

3. **üî¥ Single Source of Truth**
   - `~/DPM-V2/protocol/camera_properties.json` is the master
   - Air-Side reads directly from protocol/
   - Ground-Side must copy to assets/ before building APK

4. **üî¥ Never commit if protocol files are missing**
   - Check that `protocol/camera_properties.json` exists
   - Verify PropertyLoader can load it
   - Test before committing

### Documentation Location

**Documentation files (not protocol specs) go in docs/:**
```
~/DPM-V2/docs/
  ‚îú‚îÄ‚îÄ CC_READ_THIS_FIRST.md          ‚Üê You are here
  ‚îú‚îÄ‚îÄ CAMERA_PROPERTIES_FIX_TRACKING.md
  ‚îú‚îÄ‚îÄ ISO_AUTO_FIX_SUMMARY.md
  ‚îî‚îÄ‚îÄ protocol/                      ‚Üê Protocol DOCUMENTATION (not specs)
      ‚îú‚îÄ‚îÄ PROTOCOL_VALUE_MAPPING.md
      ‚îú‚îÄ‚îÄ README_protocol.md
      ‚îî‚îÄ‚îÄ [other protocol docs]
```

**Summary:**
- **Protocol SPECS** (JSON files) ‚Üí `~/DPM-V2/protocol/`
- **Protocol DOCS** (markdown explanations) ‚Üí `~/DPM-V2/docs/protocol/`

---

## üìã COMMON SESSION START CHECKLIST
**Every session, regardless of platform:**

### 1. Platform Identification (NEW!)
- ‚úÖ **MANDATORY** - Claude Code asks which platform
- ‚úÖ User responds: AIR, GROUND, WINDOWS, or DOCS
- ‚úÖ Claude Code sets context for entire session
- ‚úÖ All subsequent rules filtered by platform

### 2. Branch Confirmation (MANDATORY!)
- ‚úÖ **MANDATORY** - Confirm current Git branch
- ‚úÖ Run `git branch --show-current`
- ‚úÖ Should return: `main`
- ‚ö†Ô∏è **If NOT on main branch**: STOP and ask user what to do
- ‚ö†Ô∏è **Never work on wrong branch!**

### 3. Read This Document
- ‚úÖ **ALWAYS** read `CC_READ_THIS_FIRST.md` first (this file)
- This is your source of truth for workflow rules

### 4. Pull Latest Changes from Git
- ‚úÖ **MANDATORY** - Always pull latest before doing ANY work
- ‚úÖ Run `git pull origin main` at start of EVERY session
- ‚úÖ This ensures you have latest protocol definitions
- ‚úÖ This ensures you have changes from the other platform (air ‚Üî ground)
- ‚ö†Ô∏è **CRITICAL** - Never work on stale code!

**If git pull shows conflicts:**
1. **STOP** immediately
2. **Tell user**: "Git pull has conflicts that need resolution"
3. **List** the conflicting files
4. **Wait** for user to resolve or give instructions
5. **DO NOT** attempt to resolve conflicts without user approval

### 5. Check Protocol Synchronization
- ‚úÖ **MANDATORY** - Check `protocol/commands.json` for new commands
- ‚úÖ **MANDATORY** - Check `protocol/camera_properties.json` for new properties
- ‚úÖ Check if the other platform has implemented things you need to implement
- ‚úÖ **ASK USER** about any new commands/properties before implementing
- ‚ö†Ô∏è **CRITICAL** - Protocol sync MUST happen every session

**üî¥ CRITICAL: Protocol files are at ~/DPM-V2/protocol/ NOT in docs/ folder! üî¥**
**These are shared specification files used by BOTH Air-Side and Ground-Side**

**Run these checks:**

```bash
# For AIR-SIDE: Check what you need to implement
cat protocol/commands.json | jq -r '.commands | to_entries[] |
  select(.value.implemented.air_side == false) | .key'

cat protocol/camera_properties.json | jq -r '.properties | to_entries[] |
  select(.value.implemented.air_side == false) | .key'

# For GROUND-SIDE: Check what you need to implement
cat protocol/commands.json | jq -r '.commands | to_entries[] |
  select(.value.implemented.ground_side == false) | .key'

cat protocol/camera_properties.json | jq -r '.properties | to_entries[] |
  select(.value.implemented.ground_side == false) | .key'
```

### 6. Check Current Status
- ‚úÖ Read the appropriate `PROGRESS_AND_TODO.md`:
  - **Air-side:** `sbc/docs/PROGRESS_AND_TODO.md`
  - **Ground-side:** `android/docs/PROGRESS_AND_TODO.md`
  - **WindowsTools:** `WindowsTools/PROGRESS_AND_TODO.md`
- Understand:
  - What phase we're in
  - What's been completed
  - What's currently blocked
  - What to work on next

### 7. Read Relevant Technical Docs (If Needed)
- ‚ö†Ô∏è **DO NOT** read `Project_Summary_and_Action_Plan.md` unless explicitly asked
- ‚ö†Ô∏è **DO NOT** re-read technical specs you've already reviewed in this session
- ‚úÖ **DO** read specific technical docs when starting new features

**Air-Side Docs:**
- `sbc/docs/BUILD_AND_IMPLEMENTATION_PLAN.md` - When implementing new components
- `sbc/docs/DOCKER_SETUP.md` - When working with Docker or Sony SDK
- Protocol specs - When implementing protocol features
- **Sony SDK HTML Documentation** - When working on camera integration (see Air-Side section)

**Ground-Side Docs:**
- `docs/Command_Protocol_Specification_v1.0.md` - When implementing protocol features
- `docs/Protocol_Implementation_Quick_Start.md` - Protocol implementation guide
- `docs/Phase1_Requirements_Update.md` - Feature requirements
- `docs/Updated_System_Architecture_H16.md` - System architecture
- Android-specific guides when implementing UI/networking

**WindowsTools Docs:**
- `WindowsTools/PROGRESS_AND_TODO.md` - Current status and tasks
- `WindowsTools/README.md` - Setup and usage instructions

### 8. Understand Git Status
- ‚úÖ Run `git status` to check for uncommitted changes
- ‚úÖ Identify what needs to be committed
- ‚úÖ Check current branch (should be `main`)

---

## üîÑ COMMON WORKFLOW RULES
**These rules apply to ALL platforms:**

### Rule #0: Protocol Synchronization (MOST IMPORTANT!)

**üî¥ CRITICAL: Check protocol files EVERY SESSION before doing ANY work! üî¥**

#### Session Start Protocol Check

**Commands Check:**
```bash
# Check for new commands
cat protocol/commands.json | jq -r '.commands | to_entries[] |
  select(.value.implemented.SIDE_side == false) | .key'
# Replace SIDE with 'air' or 'ground'

# Check what the OTHER side has implemented
cat protocol/commands.json | jq -r '.commands | to_entries[] |
  select(.value.implemented.OTHER_side == true and
         .value.implemented.YOUR_side == false) | .key'
# These are ready to implement - the other side can already handle them!
```

**Camera Properties Check:**
```bash
# Check for new properties
cat protocol/camera_properties.json | jq -r '.properties | to_entries[] |
  select(.value.implemented.SIDE_side == false) | .key'

# Check what the OTHER side has implemented
cat protocol/camera_properties.json | jq -r '.properties | to_entries[] |
  select(.value.implemented.OTHER_side == true and
         .value.implemented.YOUR_side == false) | .key'

# Check Phase 1 priority properties
cat protocol/camera_properties.json | jq '.implementation_phases.phase_1.properties[]'
```

**If you see ANY commands OR properties listed:**
1. **STOP** and read the definition in the JSON file
2. **ASK THE USER:**
   - "I see new item(s) in the protocol: [list them]"
   - "What should these do? (for air-side) / What UI should these have? (for ground-side)"
   - "Should I implement them now, or are they planned for later?"
3. **WAIT** for user response before proceeding
4. **DO NOT** assume you know what to implement

#### Adding New Commands

**When implementing a new command:**

**Air-Side Flow:**
```
1. User adds command to protocol/commands.json
   ‚îî‚îÄ Sets "air_side": false, "ground_side": might be true

2. CC detects new command at session start
   ‚îî‚îÄ Asks user what it does and if it should be implemented

3. CC implements in C++ (tcp_server.cpp)
   ‚îú‚îÄ Add handler function (e.g., handleCameraFocus)
   ‚îú‚îÄ Add route in processCommand()
   ‚îú‚îÄ Add Sony SDK calls if needed
   ‚îú‚îÄ Add any new error codes to messages.h
   ‚îî‚îÄ Test implementation

4. CC updates commands.json
   ‚îî‚îÄ Set "air_side": true

5. CC updates sbc/docs/PROGRESS_AND_TODO.md

6. CC commits with clear message
   ‚îî‚îÄ [AIR][PROTOCOL] Implemented [command.name] command
```

**Ground-Side Flow:**
```
1. User adds command to protocol/commands.json
   ‚îî‚îÄ May add commented-out method to NetworkClient.kt

2. CC detects new command at session start
   ‚îî‚îÄ Asks user about UI requirements

3. CC implements in Kotlin
   ‚îú‚îÄ Uncomment/add method in NetworkClient.kt
   ‚îú‚îÄ Add ViewModel method to call it
   ‚îú‚îÄ Add UI button/control in appropriate Fragment
   ‚îú‚îÄ Add error handling
   ‚îî‚îÄ Test with air-side (if available)

4. CC updates commands.json
   ‚îî‚îÄ Set "ground_side": true

5. CC updates android/docs/PROGRESS_AND_TODO.md

6. CC commits with clear message
   ‚îî‚îÄ [GROUND][PROTOCOL] Implemented [command.name] UI
```

#### Camera Properties Workflow

**Key Insight:** `camera.set_property` is ONE command that sets MANY properties.

**Properties are different from commands:**
- Commands: One command ‚Üí One handler ‚Üí One UI element
- Properties: One command ‚Üí Many properties ‚Üí Many UI elements

**When implementing camera properties:**

1. **Check which properties are Phase 1:**
   ```bash
   cat protocol/camera_properties.json | jq '.implementation_phases.phase_1.properties[]'
   ```

2. **Pick ONE property to implement at a time:**
   - Start with high-priority (exposure triangle: shutter, aperture, ISO)
   - Implement air-side Sony SDK call
   - Add ground-side UI control
   - Test thoroughly
   - Mark property as implemented

3. **UI considerations (ground-side):**
   - Check `ui_hints` in camera_properties.json:
     - `dropdown` ‚Üí Spinner/Dropdown
     - `slider` ‚Üí SeekBar
     - `segmented_control` ‚Üí RadioGroup/ToggleButton
   - Different properties need different controls
   - Some properties depend on others (e.g., WB temperature requires WB mode = "temperature")

4. **Example: Implementing shutter_speed:**
   ```
   Air-Side:
   - Add to handleCameraSetProperty()
   - Map value to Sony SDK ShutterSpeedValue enum
   - Call SDK::SetDeviceProperty(CrDeviceProperty_ShutterSpeed, value)
   - Test with real camera
   - Mark "air_side": true
   
   Ground-Side:
   - Add Spinner with values from validation.values in JSON
   - Wire to networkClient.setCameraProperty("shutter_speed", value)
   - Implement validation
   - Test end-to-end
   - Mark "ground_side": true
   ```

#### Protocol Sync Rules

‚úÖ **DO:**
- Check protocol files at START of every session
- Check for both commands AND properties
- Ask user about new items before implementing
- Verify the other platform's status before implementing
- Update JSON files immediately after implementing
- Keep JSON as single source of truth
- Implement incrementally (one command/property at a time)
- Test thoroughly before marking as implemented

‚ùå **DON'T:**
- Implement commands/properties not in JSON files
- Assume what something should do without asking
- Mark implemented until fully done and tested
- Skip protocol check at session start
- Implement multiple things at once
- Send commands/properties the other side can't handle

### Rule #1: Update PROGRESS_AND_TODO.md After Every Significant Change

**When to update:**
- ‚úÖ After completing any task in a phase
- ‚úÖ After discovering/resolving a bug
- ‚úÖ After creating new files
- ‚úÖ After significant debugging sessions
- ‚úÖ When switching from one phase/component to another
- ‚úÖ **AT MINIMUM: At end of every work session**

**What to update:**
```markdown
## RECENT UPDATES (October XX, 2025)
- Add new developments at the top
- Keep dated entries

## [Current Phase Section]
- Update task checkboxes: [ ] ‚Üí [x]
- Update status notes
- Document any blockers

## OVERALL PROGRESS
- Update completion percentages
- Update visual progress bars
- Update "Last Updated" timestamp

## ISSUE TRACKER
- Add new issues discovered
- Update status of existing issues
- Mark resolved issues
```

**Format Example:**
```markdown
**Last Updated:** October 29, 2025 15:30 - After implementing shutter_speed property
```

### Rule #2: Commit to Git Regularly (UPDATED WITH PLATFORM PREFIXES!)

**üî¥ NEW REQUIREMENT: All commits MUST include platform prefix! üî¥**

**Commit frequency rules:**

1. **After completing any functional unit:**
   - ‚úÖ New feature implemented and tested
   - ‚úÖ Bug fixed and verified
   - ‚úÖ New component created
   - ‚úÖ Documentation updated significantly

2. **Time-based minimum:**
   - ‚úÖ Commit at least every 30-60 minutes of active work
   - Even if work is incomplete - use WIP tag

3. **Before switching tasks:**
   - ‚úÖ Always commit current work before starting something new

4. **At end of session:**
   - ‚úÖ **MANDATORY** - Commit all changes before ending work
   - Update docs first, then commit

**Commit Message Format (UPDATED!):**

```bash
[PLATFORM][TYPE] Component: Brief one-line summary (max 72 chars)

- Detailed point 1 (what changed)
- Detailed point 2 (why it changed)
- Detailed point 3 (impact/result)
```

**Valid PLATFORM prefixes:**
- `[AIR]` - Air-side (C++ SBC) changes
- `[GROUND]` - Ground-side (Android) changes
- `[WINDOWS]` - WindowsTools (Python diagnostic) changes
- `[DOCS]` - Documentation/Protocol (cross-platform)

**Valid TYPE prefixes:**
- `[FEATURE]` - New functionality
- `[FIX]` - Bug fix
- `[PROTOCOL]` - Protocol implementation
- `[DOCS]` - Documentation update
- `[REFACTOR]` - Code restructuring
- `[TEST]` - Testing additions
- `[BUILD]` - Build system changes
- `[WIP]` - Work in progress

**Platform Prefix Rules:**
- ‚úÖ **AIR-SIDE work**: MUST use `[AIR]` prefix
- ‚úÖ **GROUND-SIDE work**: MUST use `[GROUND]` prefix
- ‚úÖ **WINDOWSTOOLS work**: MUST use `[WINDOWS]` prefix
- ‚úÖ **DOCS/PROTOCOL**: Use `[DOCS]` prefix (no platform-specific code)
- ‚úÖ **Cross-platform changes**: Use multiple commits, one per platform

**Good Examples:**
```bash
[AIR][PROTOCOL] Camera: Implemented shutter_speed property

- Air-side: Sony SDK CrDeviceProperty_ShutterSpeed integration
- Added validation for shutter speed values
- Updated handleCameraSetProperty() handler
- Testing: Verified with Sony A1 camera

[GROUND][PROTOCOL] Camera: Implemented shutter_speed UI

- Added Spinner with standard shutter speeds
- Connected to networkClient.setCameraProperty()
- Validation: Enum values from camera_properties.json
- Testing: Verified end-to-end with air-side

[AIR][FIX] Docker: Resolved CrAdapter dynamic loading issue

- Root cause: Adapters statically linked in CMakeLists.txt
- Solution: Only link libCr_Core.so, copy CrAdapter/ to build dir
- Result: SDK now loads adapters dynamically

[GROUND][FEATURE] Android: Added camera control screen

- Implemented CameraControlFragment with MVVM pattern
- Added exposure controls (shutter, aperture, ISO)
- Connected to NetworkClient for command sending
- Tested on emulator and H16 hardware

[WINDOWS][FEATURE] Protocol Inspector: Added JSON formatting

- Implemented syntax highlighting for JSON messages
- Added expand/collapse for nested structures
- Improved readability of protocol messages

[DOCS] Protocol: Added focus control commands

- Updated commands.json with camera.focus command
- Added camera.set_focus_area command
- Both marked air_side=false, ground_side=false
- Ready for implementation in next session

[AIR][WIP] Camera: Partial Sony SDK integration

- Connected to camera successfully
- Can read properties but not set yet
- Need to debug SetDeviceProperty callback issue
- Committing for end of session
```

**Bad Examples:**
```bash
# Missing platform prefix
[FEATURE] Added stuff

# No context
Fixed bug

# Too long in title
[AIR][FEATURE] Implemented camera shutter speed property control with dropdown UI and validation

# No details
[GROUND][FIX] Camera works now

# Wrong platform prefix (air work with ground prefix)
[GROUND][PROTOCOL] Implemented C++ camera handler
```

**Cross-Platform Changes:**
If you modify multiple platforms in one session, make **separate commits**:

```bash
# Commit 1: Air-side changes
git add sbc/
git commit -m "[AIR][PROTOCOL] Camera: Implemented shutter_speed handler"

# Commit 2: Ground-side changes
git add android/
git commit -m "[GROUND][PROTOCOL] Camera: Added shutter_speed UI"

# Commit 3: WindowsTools changes
git add WindowsTools/
git commit -m "[WINDOWS][FEATURE] Added shutter_speed display"

# Commit 4: Protocol updates
git add protocol/
git commit -m "[DOCS] Protocol: Marked shutter_speed implemented all sides"
```

### üî¥ NEW REQUIREMENT: Cross-Platform Implementation Instructions

**CRITICAL: When Claude Code works on one platform and the changes will impact another platform, the commit message MUST include detailed implementation instructions for that platform!**

**Why This Matters:**
- The other platform's Claude Code instance needs to understand what was done
- Detailed commit messages enable the other platform to integrate smoothly
- Prevents miscommunication and implementation errors
- Provides context that code alone cannot convey

**When This Applies:**
- ‚úÖ Implementing a feature on Air-Side that Ground-Side will need to use
- ‚úÖ Implementing a feature on Ground-Side that Air-Side will need to support
- ‚úÖ Fixing a bug on one side that affects the other side
- ‚úÖ Making protocol changes that both sides need to understand
- ‚úÖ Implementing diagnostic features that reveal issues on other platforms

**Commit Message Format for Cross-Platform Work:**

```bash
[PLATFORM][TYPE] Component: Brief summary

Root Cause / Context:
- What problem this solves
- Why this approach was chosen
- What was wrong before

Technical Details:
- Specific implementation details
- SDK functions used (if Air-Side)
- UI components added (if Ground-Side)
- Protocol messages involved
- Timing/sequencing requirements
- Error handling approach

Fixes / Implements:
- List specific issues resolved
- List specific features enabled
- Note any side effects or limitations

Testing:
- How it was tested
- Test results
- What scenarios were verified

Files Changed:
- path/to/file.cpp (method_name, lines X-Y)
- path/to/other_file.h (added new_function)

Documentation:
- Links to any docs created
- Summary docs if extensive
- API documentation updates

For [OTHER_PLATFORM] Integration:
- Specific instructions for the other platform
- Expected behavior from this side
- Protocol expectations
- Error codes to handle
- Timing considerations
```

**Excellent Example (Air-Side Fix with Ground-Side Instructions):**

```bash
[AIR][FIX] Camera: Fix focus control SDK error 0x8402

Root Cause:
- FocalDistanceInMeter property not properly validated as "enabled"
- SDK requires property state checks before Focus_Operation calls
- Missing timing delays caused interference between operations

Technical Details:
- Added Focus_Speed_Range query to validate and clamp speed values (1-3)
- Added property state checks before Focus_Operation attempts
- Added timing delays: 50ms post-query, 100ms post-command
- Enhanced error logging with specific failure diagnostics
- Created diagnostic version for troubleshooting camera-specific issues

Sony SDK Functions Used:
- CrDeviceProperty_FocalDistanceInMeter (validation)
- CrDeviceProperty_Focus_Speed_Range (speed clamping)
- CrDeviceProperty_Focus_Operation (near/far/stop)
- CrDeviceProperty_AutoFocusHold (press/release)

Fixes:
- SDK error 0x8402 (CrError_Api_InvalidCalled) on all focus commands
- Focus operations (near/far/stop) now work reliably
- Property readback slowdown after focus commands resolved
- Auto-focus hold (press/release) now functional

Testing:
- Verified focus commands execute without errors
- Focal distance updates correctly during operation
- Property queries remain responsive after focus commands
- Tested all 6 speed levels (near 1-3, far 1-3)
- Tested auto-focus hold press and release

Files Changed:
- sbc/src/camera/camera_sony.cpp (focus() method, lines 356-430)
- sbc/src/camera/camera_sony.h (added focus speed validation)
- sbc/include/protocol/messages.h (added focus error codes)

Documentation:
- Added docs/FOCUS_FIX_INSTRUCTIONS.md (implementation guide)
- Added docs/FOCUS_FIX_SUMMARY.md (executive summary)
- Created diagnostic version in camera_sony_diagnostic.cpp
- Created production fix in camera_sony_fixed.cpp

For GROUND-SIDE Integration:
- Focus commands now work as documented in protocol
- Expected response time: <100ms for command acknowledgment
- Focal distance updates arrive via UDP status broadcasts
- Error codes to handle:
  * 0x8402: Camera not ready (retry after 100ms)
  * Focus speed auto-clamped to 1-3 range (no error if out of range)
- Timing: Wait 100ms between consecutive focus commands
- UI Recommendation: Disable focus buttons during active operation
- Testing: Use diagnostic mode logs if issues occur
```

**Good Example (Ground-Side UI with Air-Side Context):**

```bash
[GROUND][FEATURE] Camera: Add manual focus controls UI

Context:
- Implements Phase 1 manual focus per Focus_Control_Implementation_Guide.md
- Air-Side focus commands implemented and tested in commit c83a58a
- Provides 6-speed directional control (near/far, speeds 1-3)

UI Implementation:
- Added FocusSection component with 6 direction/speed buttons
- Added AutoFocusHoldButton with press-and-hold behavior
- Added focus mode display (MF/AF-S/AF-C) from camera status
- Visual feedback: AF button changes gray‚Üígreen when pressed
- Icons: üë§ for near (person), üèîÔ∏è for far (mountain)

NetworkClient Methods:
- focusCamera(action: String, speed: Int) sends camera.focus command
- setAutoFocusHold(state: String) sends camera.auto_focus_hold command
- Parameters validated before sending

Protocol Messages:
- camera.focus: {action: "near"/"far"/"stop", speed: 1-3}
- camera.auto_focus_hold: {state: "press"/"release"}

Files Changed:
- app/src/main/java/com/dpm/groundstation/ui/SonyRemoteControlScreen.kt
  * Added FocusSection component (lines 958-1037)
  * Added AutoFocusHoldButton composable (lines 1063-1116)
- app/src/main/java/com/dpm/groundstation/network/NetworkClient.kt
  * Added focusCamera() method (line 245)
  * Added setAutoFocusHold() method (line 267)

Testing:
- ‚úÖ Buttons trigger correct protocol messages
- ‚úÖ AF Hold button responds to press/release correctly
- ‚úÖ Focus mode display updates from UDP status
- ‚è≥ End-to-end testing with Air-Side pending

For AIR-SIDE Context:
- Ground-Side sends focus commands as documented
- Expects camera.focus response within 100ms
- Expects focal_distance updates via UDP status broadcasts
- Will display focus mode from status.camera.focus_mode field
- May send rapid commands if user holds button - Air-Side should debounce
```

**Bad Example (Missing Context):**

```bash
[AIR][FIX] Camera: Fixed focus

- Fixed the focus bug
- It works now
```

**Why This is Bad:**
- No explanation of what was wrong
- No technical details for debugging
- No testing information
- Ground-Side has no idea what changed or how to use it
- Future Claude Code instances can't understand the fix

**Enforcement:**

‚úÖ **DO:**
- Include root cause analysis for fixes
- List all technical changes in detail
- Specify exact SDK functions/API calls used
- Document timing and sequencing requirements
- Provide test results and verification steps
- Include explicit instructions for other platform
- List all files changed with line numbers
- Reference created documentation

‚ùå **DON'T:**
- Write vague commit messages like "fixed bug"
- Assume other platform will figure it out
- Skip technical details "to save time"
- Forget to mention protocol changes
- Leave out testing information
- Omit error handling details
- Forget timing requirements

### Rule #3: Never Leave Orphaned Documentation

**Before making code changes:**
- ‚úÖ Check if any documentation references affected code
- ‚úÖ Plan documentation updates alongside code changes

**After making code changes:**
- ‚úÖ Update relevant technical documentation
- ‚úÖ Update appropriate PROGRESS_AND_TODO.md
- ‚úÖ Update protocol JSON files if implementing commands/properties
- ‚úÖ Update BUILD_AND_IMPLEMENTATION_PLAN.md if architecture changed (air-side)
- ‚úÖ Update DOCKER_SETUP.md if Docker/build process changed (air-side)

**Documentation to code ratio:**
- For every 100 lines of code, expect ~20-30 lines of documentation updates
- If you wrote code but didn't update any docs, something is wrong!

### Rule #4: Build Verification Before Committing

**MANDATORY: Every commit must have a working build**

**Air-Side (C++):**
```bash
cd sbc/build
cmake ..
make -j4

# If build fails, FIX IT before committing
# If build succeeds, optionally run tests:
./test_camera  # or other test executables
```

**Ground-Side (Android):**
```bash
cd android
./gradlew assembleDebug

# If build fails, FIX IT before committing
# Success produces: app/build/outputs/apk/debug/app-debug.apk
```

**WindowsTools (Python):**
```bash
cd WindowsTools
python DiagnosticTool.py  # Should launch without errors

# If errors occur, FIX IT before committing
# Test all tabs load correctly
```

**Never commit broken code!**

### Rule #5: Work Incrementally

**Implement one thing at a time:**
- ‚úÖ One command/property fully before starting another
- ‚úÖ One component fully before starting another
- ‚úÖ One bug fix fully before starting another

**Testing at each step:**
- ‚úÖ Test immediately after implementing
- ‚úÖ Don't accumulate untested code
- ‚úÖ Fix issues before moving on

**Benefits:**
- Easier to debug (smaller changes)
- Clearer git history
- Less overwhelming
- Higher quality

---

## üîπ AIR-SIDE SPECIFICS (C++ SBC)

### Air-Side Session Start Extensions

**Additional checks for C++ development:**

1. **Check Docker Status** (if using Docker):
   ```bash
   docker ps | grep dpm
   # Should show running container if applicable
   ```

2. **Verify Sony SDK:**
   ```bash
   ls ~/sony_sdk/lib/
   # Should see libCr_Core.so and CrAdapter/ directory
   ```

3. **Locate Sony SDK HTML Documentation:**
   ```bash
   # Sony SDK API documentation location:
   ~/sony_sdk/doc/html/index.html
   
   # CRITICAL: Always reference Sony SDK documentation when:
   # - Implementing new camera properties
   # - Working with Sony SDK API calls
   # - Debugging Sony SDK errors
   # - Understanding property enums and values
   ```

4. **Check Build Directory:**
   ```bash
   ls sbc/build/
   # Should exist and contain CMake files
   ```

### C++ Build System

**CMake Configuration:**
```bash
cd sbc/build
cmake .. -DCMAKE_BUILD_TYPE=Debug  # For development
cmake .. -DCMAKE_BUILD_TYPE=Release  # For production

make -j4  # Use 4 parallel jobs
```

**Build Targets:**
```bash
make payload_server    # Main executable
make test_camera       # Camera test utility
make clean             # Clean build artifacts
make install           # Install to system (optional)
```

**Build Output:**
- Executables: `sbc/build/`
- Libraries: `sbc/build/lib/`

### Docker Workflow (If Applicable)

**Starting Docker Container:**
```bash
cd sbc
docker-compose up -d  # Start in background
docker-compose logs -f  # View logs
```

**Accessing Container:**
```bash
docker exec -it dpm-sbc bash
# Now you're inside the container
cd /workspace
```

**Building Inside Docker:**
```bash
docker exec -it dpm-sbc bash
cd /workspace/build
cmake ..
make -j4
```

**Stopping Docker:**
```bash
docker-compose down
```

### Memory Leak Testing

**MANDATORY for C++ development:**

```bash
# After every significant change, run valgrind:
cd sbc/build
valgrind --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         --verbose \
         --log-file=valgrind-out.txt \
         ./payload_server

# Check the output:
cat valgrind-out.txt | grep "definitely lost"
cat valgrind-out.txt | grep "indirectly lost"

# Should see: "All heap blocks were freed -- no leaks are possible"
```

**When to run valgrind:**
- ‚úÖ After implementing new features
- ‚úÖ Before committing significant changes
- ‚úÖ Weekly during active development
- ‚úÖ Before marking tasks as complete

### Sony SDK Integration

**üî¥ CRITICAL: Always check Sony SDK HTML documentation before implementing!**

**Documentation Location:**
```bash
~/sony_sdk/doc/html/index.html
```

**Key Documentation Sections:**
- API Reference ‚Üí Device Properties ‚Üí Camera Properties
- Class Reference ‚Üí SCRSDK namespace
- Examples ‚Üí Remote Sample Application

**Common SDK Operations:**

```cpp
// Initialize SDK
CrInt32u ret = SDK::Init();

// Get device list
ICrEnumCameraObjectInfo* camera_list = nullptr;
ret = SDK::EnumCameraObjects(&camera_list);

// Connect to camera
SDK::Connect(device_handle, callback);

// Get property
SDK::GetDeviceProperty(device_handle, property_code, &value);

// Set property
SDK::SetDeviceProperty(device_handle, property_code, &value);

// Release SDK
SDK::Release();
```

**Error Code Handling:**
```cpp
if (ret != CrError_None) {
    // Map to DPM error codes
    return ErrorCode::CAMERA_ERROR;
}
```

**When Implementing New Camera Properties:**
1. Open Sony SDK HTML docs
2. Find the property in CrDeviceProperty enum
3. Check available values in corresponding Value enum
4. Note any dependencies or restrictions
5. Implement using documented approach
6. Test with actual camera

### C++ Best Practices (Mandatory)

**C++17 Features:**
- ‚úÖ Use `std::unique_ptr` and `std::shared_ptr` for memory management
- ‚úÖ Use RAII for resource management
- ‚úÖ Use `std::optional` for optional values
- ‚úÖ Use structured bindings where appropriate
- ‚úÖ Use `constexpr` for compile-time constants

**Threading:**
- ‚úÖ Use `std::thread` for threads
- ‚úÖ Use `std::mutex` for synchronization
- ‚úÖ Use `std::lock_guard` or `std::unique_lock` for lock management
- ‚úÖ Avoid manual lock/unlock

**Memory Management:**
- ‚úÖ Prefer stack allocation over heap
- ‚úÖ Use smart pointers for heap allocation
- ‚úÖ Never use raw `new`/`delete` without good reason
- ‚úÖ Initialize all variables
- ‚úÖ Use `std::vector` instead of C arrays

**Error Handling:**
- ‚úÖ Return error codes or exceptions
- ‚úÖ Check all Sony SDK return values
- ‚úÖ Log errors appropriately
- ‚úÖ Clean up resources on error paths

**Code Organization:**
```cpp
// Good structure:
class CameraManager {
private:
    std::unique_ptr<SonyCameraImpl> impl_;
    std::mutex mutex_;
    
public:
    CameraManager() = default;
    ~CameraManager() = default;
    
    // Disable copy
    CameraManager(const CameraManager&) = delete;
    CameraManager& operator=(const CameraManager&) = delete;
    
    // Enable move
    CameraManager(CameraManager&&) = default;
    CameraManager& operator=(CameraManager&&) = default;
    
    ErrorCode connect();
    ErrorCode setProperty(const std::string& property, const PropertyValue& value);
};
```

### Air-Side File Structure

```
sbc/
‚îú‚îÄ‚îÄ CMakeLists.txt           # Main CMake config
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.cpp             # Entry point
‚îÇ   ‚îú‚îÄ‚îÄ config.h             # Configuration constants
‚îÇ   ‚îú‚îÄ‚îÄ network/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tcp_server.cpp   # TCP command server
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ udp_broadcaster.cpp  # UDP status/heartbeat
‚îÇ   ‚îú‚îÄ‚îÄ protocol/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ message_handler.cpp  # JSON message processing
‚îÇ   ‚îú‚îÄ‚îÄ camera/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sony_camera.cpp  # Sony SDK wrapper
‚îÇ   ‚îî‚îÄ‚îÄ gimbal/
‚îÇ       ‚îî‚îÄ‚îÄ gimbal_interface.cpp  # Gimbal control
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îî‚îÄ‚îÄ [corresponding headers]
‚îú‚îÄ‚îÄ build/                   # CMake build directory
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ test_camera.cpp      # Test utilities
‚îî‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ PROGRESS_AND_TODO.md
    ‚îú‚îÄ‚îÄ BUILD_AND_IMPLEMENTATION_PLAN.md
    ‚îî‚îÄ‚îÄ DOCKER_SETUP.md
```

### Air-Side Troubleshooting

**Issue: "Sony SDK header not found"**
```bash
# Check SDK location
ls ~/sony_sdk/include/
# Should see CrTypes.h, ICrCameraObjectInfo.h, etc.

# Verify CMakeLists.txt includes:
include_directories(${CMAKE_SOURCE_DIR}/../sony_sdk/include)
```

**Issue: "libCr_Core.so: cannot open shared object file"**
```bash
# Add to LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/sony_sdk/lib

# Or add to CMakeLists.txt:
set(CMAKE_INSTALL_RPATH "${CMAKE_SOURCE_DIR}/../sony_sdk/lib")
```

**Issue: "Camera not detected"**
```bash
# Check USB connection
lsusb | grep Sony
# Should see: Bus XXX Device XXX: ID 054c:XXXX Sony Corp.

# Check permissions
ls -l /dev/bus/usb/XXX/XXX
# Should be accessible by your user

# Check udev rules:
cat /etc/udev/rules.d/99-sony-camera.rules
# Should have: SUBSYSTEM=="usb", ATTR{idVendor}=="054c", MODE="0666"
```

**Issue: "Valgrind reports memory leaks"**
```bash
# Common causes:
# 1. Forgot to release Sony SDK
# 2. Raw pointers instead of smart pointers
# 3. Circular references in shared_ptr

# Fix:
# - Ensure SDK::Release() is called
# - Convert raw pointers to unique_ptr/shared_ptr
# - Break circular references with weak_ptr
```

**Issue: "Don't know which Sony SDK property to use"**
```bash
# SOLUTION: Open Sony SDK HTML documentation
open ~/sony_sdk/doc/html/index.html

# Navigate to:
# 1. API Reference ‚Üí Device Properties
# 2. Find the property you need
# 3. Check available values and enums
# 4. Review example code if available
```

---

## üîπ GROUND-SIDE SPECIFICS (Android App)

### Ground-Side Session Start Extensions

**Additional checks for Android development:**

1. **Check Gradle Status:**
   ```bash
   cd android
   ./gradlew --status
   ```

2. **Check Device Connection:**
   ```bash
   adb devices
   # Should show connected device or emulator
   ```

3. **Check for Wireless ADB (H16):**
   ```bash
   adb connect 192.168.144.11:5555
   ```

### Android Build System

**Gradle Build:**
```bash
cd android

# Clean build
./gradlew clean

# Build debug APK
./gradlew assembleDebug

# Build release APK (signed)
./gradlew assembleRelease

# Install on connected device
./gradlew installDebug

# Run tests
./gradlew test
```

**Build Output:**
- Debug APK: `app/build/outputs/apk/debug/app-debug.apk`
- Release APK: `app/build/outputs/apk/release/app-release.apk`

### APK Deployment

**Install via ADB:**
```bash
# Install new APK
adb install -r app/build/outputs/apk/debug/app-debug.apk

# Install to specific device
adb -s <device_id> install -r app-debug.apk

# Uninstall first (if needed)
adb uninstall com.dpm.groundstation
adb install app-debug.apk
```

**Launch App:**
```bash
adb shell am start -n com.dpm.groundstation/.MainActivity
```

### Viewing Logs

**Logcat:**
```bash
# View all app logs
adb logcat | grep DPM

# View specific tag
adb logcat -s NetworkClient

# Save to file
adb logcat > logcat.txt

# Clear logs first
adb logcat -c
adb logcat | grep DPM
```

### Commented-Out Commands Workflow (Ground-Side)

**Ground-side uses a specific pattern for planned features:**

```kotlin
class NetworkClient {
    // ‚úÖ IMPLEMENTED commands
    fun captureImage() {
        val command = Command(...)
        sendCommand(command)
    }

    // üîú PLANNED commands (commented out until ready)
    // fun setCameraProperty(property: String, value: Any) {
    //     val command = Command(
    //         command = "camera.set_property",
    //         parameters = mapOf("property" to property, "value" to value)
    //     )
    //     sendCommand(command)
    // }

    // fun focusCamera(direction: String, speed: Int = 3) {
    //     val command = Command(
    //         command = "camera.focus",
    //         parameters = mapOf("action" to direction, "speed" to speed)
    //     )
    //     sendCommand(command)
    // }
}
```

**CC Workflow:**
1. At session start, search for `// fun` in NetworkClient.kt
2. Ask user: "I see X commented-out commands. Should I implement any?"
3. Check if air-side has implemented the handler
4. If air-side ready + user approves:
   - Uncomment the method
   - Add ViewModel method
   - Add UI elements to call it
   - Test end-to-end
   - Update `commands.json` to `"ground_side": true`

### Android Architecture (MVVM)

**Required Pattern:**

```
UI Layer (Fragment/Activity)
    ‚Üì observes
ViewModel (holds UI state)
    ‚Üì calls
Repository (optional, for complex data)
    ‚Üì calls
NetworkClient (protocol implementation)
    ‚Üì sends
Network Commands
```

**Example:**
```kotlin
// Fragment
class CameraControlFragment : Fragment() {
    private val viewModel: CameraViewModel by viewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        viewModel.cameraState.observe(viewLifecycleOwner) { state ->
            // Update UI
        }
        
        binding.captureButton.setOnClickListener {
            viewModel.captureImage()
        }
    }
}

// ViewModel
class CameraViewModel(private val networkClient: NetworkClient) : ViewModel() {
    private val _cameraState = MutableLiveData<CameraState>()
    val cameraState: LiveData<CameraState> = _cameraState
    
    fun captureImage() {
        viewModelScope.launch {
            try {
                networkClient.captureImage()
                _cameraState.value = CameraState.Capturing
            } catch (e: Exception) {
                _cameraState.value = CameraState.Error(e.message)
            }
        }
    }
}
```

### Kotlin Best Practices (Mandatory)

**Coroutines:**
- ‚úÖ Use `viewModelScope` in ViewModels
- ‚úÖ Use `lifecycleScope` in Fragments/Activities
- ‚úÖ Use `Dispatchers.IO` for network/disk operations
- ‚úÖ Use `Dispatchers.Main` for UI updates
- ‚úÖ Handle cancellation properly

**Null Safety:**
- ‚úÖ Use nullable types (`Type?`) when values can be null
- ‚úÖ Use safe calls (`?.`) for nullable access
- ‚úÖ Use `!!` only when absolutely certain non-null
- ‚úÖ Prefer `?.let { }` over null checks

**Data Classes:**
- ‚úÖ Use `data class` for models
- ‚úÖ Use `sealed class` for state representations
- ‚úÖ Prefer immutability (`val` over `var`)

**Example:**
```kotlin
// State representation
sealed class CameraState {
    object Idle : CameraState()
    object Connecting : CameraState()
    object Connected : CameraState()
    object Capturing : CameraState()
    data class Error(val message: String) : CameraState()
}

// Data model
data class CameraSettings(
    val shutterSpeed: String,
    val aperture: String,
    val iso: Int,
    val whiteBalance: String
)
```

### Ground-Side File Structure

```
android/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle
‚îÇ   ‚îî‚îÄ‚îÄ src/main/
‚îÇ       ‚îú‚îÄ‚îÄ AndroidManifest.xml
‚îÇ       ‚îú‚îÄ‚îÄ java/com/dpm/groundstation/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ MainActivity.kt
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ camera/
‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CameraControlFragment.kt
‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CameraViewModel.kt
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ status/
‚îÇ       ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ StatusFragment.kt
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ network/
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NetworkClient.kt
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NetworkSettings.kt
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProtocolMessages.kt
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ util/
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ Extensions.kt
‚îÇ       ‚îî‚îÄ‚îÄ res/
‚îÇ           ‚îú‚îÄ‚îÄ layout/
‚îÇ           ‚îú‚îÄ‚îÄ values/
‚îÇ           ‚îî‚îÄ‚îÄ drawable/
‚îú‚îÄ‚îÄ build.gradle
‚îú‚îÄ‚îÄ settings.gradle
‚îî‚îÄ‚îÄ docs/
    ‚îî‚îÄ‚îÄ PROGRESS_AND_TODO.md
```

### Ground-Side Troubleshooting

**Issue: "Gradle build failed"**
```bash
# Check error messages
./gradlew assembleDebug --stacktrace

# Common causes:
# 1. Dependency conflict ‚Üí Update versions in build.gradle
# 2. Kotlin compilation error ‚Üí Check syntax and imports
# 3. Resource issue ‚Üí Check XML files
# 4. Cache corruption ‚Üí ./gradlew clean or invalidate caches
```

**Issue: "Can't connect to device via ADB"**
```bash
# Check device connection
adb devices

# If "unauthorized":
# - Check device screen for USB debugging prompt
# - Allow debugging on device

# If device not showing:
# - Enable developer options on device
# - Enable USB debugging
# - Try different USB port
# - Restart ADB: adb kill-server && adb start-server

# For H16 (wireless):
adb connect 192.168.144.11:5555
```

**Issue: "App crashes on startup"**
```bash
# View crash logs
adb logcat | grep AndroidRuntime

# Common causes:
# 1. Missing permissions in manifest
# 2. Null pointer exception ‚Üí Check initialization
# 3. Network on main thread ‚Üí Use coroutines
# 4. Resource not found ‚Üí Clean and rebuild
```

**Issue: "Network connection failing"**
```bash
# Verify network in logcat
adb logcat | grep DPM

# Check:
# 1. INTERNET permission in manifest
# 2. Correct IP address (192.168.144.20)
# 3. Correct ports (5000 TCP, 5001/5002 UDP)
# 4. Air-side service running
# 5. Firewall not blocking
```

---

## üîπ WINDOWSTOOLS SPECIFICS (Python Diagnostic)

### WindowsTools Overview

**Purpose:** Python/tkinter diagnostic tool for monitoring and testing DPM protocol on Windows PC

**Current Status:** Phase 2 Complete (Core Monitoring)
- Connection Monitor
- Protocol Inspector
- Command Sender
- Camera Dashboard
- System Monitor

**Key Features:**
- Real-time TCP/UDP protocol monitoring
- Send test commands to Air-Side
- View camera status and system health
- JSON formatting and syntax highlighting
- Callback-based architecture

### WindowsTools Session Start Extensions

**Additional checks for Python development:**

1. **Check Python Version:**
   ```bash
   python --version
   # Should be Python 3.9 or newer
   ```

2. **Check Dependencies:**
   ```bash
   cd WindowsTools
   pip list | grep -E "tkinter|netifaces"
   ```

3. **Test Application Launch:**
   ```bash
   python DiagnosticTool.py
   # Should open GUI without errors
   ```

### WindowsTools Architecture

**File Structure:**
```
WindowsTools/
‚îú‚îÄ‚îÄ DiagnosticTool.py          # Main entry point
‚îú‚îÄ‚îÄ config.json                # User settings (IP, ports)
‚îú‚îÄ‚îÄ README.md                  # Setup instructions
‚îú‚îÄ‚îÄ PROGRESS_AND_TODO.md       # Development status
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ connection_manager.py  # TCP/UDP networking
‚îÇ   ‚îú‚îÄ‚îÄ tab_connection.py      # Connection Monitor tab
‚îÇ   ‚îú‚îÄ‚îÄ tab_protocol.py        # Protocol Inspector tab
‚îÇ   ‚îú‚îÄ‚îÄ tab_command.py         # Command Sender tab
‚îÇ   ‚îú‚îÄ‚îÄ tab_camera.py          # Camera Dashboard tab
‚îÇ   ‚îî‚îÄ‚îÄ tab_system.py          # System Monitor tab
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ logger.py              # Logging utilities
```

### Critical WindowsTools Rules

**üî¥ RULE #1: ONLY modify files in WindowsTools/ directory**
- Never modify Air-Side C++ code
- Never modify Ground-Side Android code
- Never modify protocol/ files (read-only for WindowsTools)
- Only work within WindowsTools/ boundary

**üî¥ RULE #2: Callback Chaining Pattern (MANDATORY!)**

WindowsTools uses a callback-based architecture. **NEVER replace existing callbacks!**

**‚ùå WRONG - Replaces callback:**
```python
# This BREAKS other components!
connection_manager.set_status_callback(my_new_callback)
```

**‚úÖ CORRECT - Chains callback:**
```python
# Get existing callback
existing_callback = connection_manager.status_callback

# Create new callback that calls both
def chained_callback(data):
    # Call existing first (maintains others' functionality)
    if existing_callback:
        existing_callback(data)
    
    # Then do your work
    my_processing(data)

# Set the chained callback
connection_manager.set_status_callback(chained_callback)
```

**Why This Matters:**
- Multiple tabs may listen to the same callback
- Replacing a callback breaks other components
- Always chain callbacks to preserve functionality

**Callback Types in WindowsTools:**
- `status_callback` - UDP status messages (5 Hz)
- `heartbeat_callback` - UDP heartbeat messages (1 Hz)
- `response_callback` - TCP command responses
- `connection_callback` - TCP connection state changes

### WindowsTools Best Practices

**Python Style:**
- ‚úÖ Follow PEP 8 style guidelines
- ‚úÖ Use type hints where appropriate
- ‚úÖ Document functions with docstrings
- ‚úÖ Keep functions focused and small

**GUI Threading:**
- ‚úÖ Never block the GUI thread
- ‚úÖ Use `threading.Thread(daemon=True)` for background tasks
- ‚úÖ Use `.after()` or callbacks to update GUI from threads
- ‚úÖ Test that GUI remains responsive

**Error Handling:**
- ‚úÖ Catch and log network errors
- ‚úÖ Display user-friendly error messages
- ‚úÖ Don't crash on malformed protocol messages
- ‚úÖ Validate JSON before parsing

**Configuration:**
- ‚úÖ Store user settings in `config.json`
- ‚úÖ Provide sensible defaults
- ‚úÖ Validate IP addresses and ports
- ‚úÖ Save configuration on exit

### WindowsTools Development Workflow

**When adding a new feature:**

1. **Plan the feature**
   - Which tab does it belong in?
   - What protocol messages does it need?
   - What callbacks are required?

2. **Update appropriate component file**
   - `tab_connection.py` - Connection status features
   - `tab_protocol.py` - Protocol inspection features
   - `tab_command.py` - Command sending features
   - `tab_camera.py` - Camera status features
   - `tab_system.py` - System health features

3. **Chain callbacks properly**
   - Get existing callback first
   - Create chained callback
   - Set chained callback

4. **Test thoroughly**
   - Test with Air-Side running
   - Test with Air-Side not running
   - Test rapid message flow
   - Test GUI responsiveness

5. **Update documentation**
   - Update `WindowsTools/PROGRESS_AND_TODO.md`
   - Update `WindowsTools/README.md` if user-facing
   - Document any new dependencies

### WindowsTools Troubleshooting

**Issue: "Application won't start"**
```bash
# Check Python version
python --version  # Must be 3.9+

# Check tkinter installed
python -c "import tkinter"  # Should not error

# Check for syntax errors
python -m py_compile DiagnosticTool.py
```

**Issue: "Can't connect to Air-Side"**
```bash
# Check IP configuration in config.json
cat config.json  # Verify air_side_ip is correct

# Check network connectivity
ping 192.168.144.20  # Or your Air-Side IP

# Check Air-Side is running
# Use Protocol Inspector tab to see if messages arriving
```

**Issue: "UDP messages not received"**
```bash
# Check UDP listeners started (should auto-start on TCP connect)
# Check Windows firewall allows Python to receive UDP
# Check Air-Side is sending UDP broadcasts
# Use Protocol Inspector tab to see if messages arriving
```

**Issue: "Callbacks not firing"**
```bash
# Check callback chaining (see Callback Chaining Pattern above)
# Ensure you're not replacing other components' callbacks
# Use logger.debug() to trace callback execution
```

**Issue: "GUI freezes"**
```bash
# Never block GUI thread with long operations
# Use threading.Thread(daemon=True) for background tasks
# Use .after() or callbacks to update GUI from background threads
```

### Phase Status (As of Oct 29, 2025)

**‚úÖ Phase 1 - Foundation:** 100% Complete
- Basic TCP client
- Configuration management
- Connection Monitor tab
- Configuration tab

**‚úÖ Phase 2 - Core Monitoring:** 100% Complete
- UDP status/heartbeat listeners
- Protocol Inspector tab
- Command Sender tab
- Camera Dashboard tab
- System Monitor tab
- Full protocol monitoring operational

**‚è≥ Phase 3 - Advanced:** 0% Not Started
- Docker logs viewer (SSH integration)
- Real-time graphs (matplotlib)
- Custom command templates
- Advanced filtering

**‚è≥ Phase 4 - Testing:** 0% Not Started
- Automated test sequences
- Stress testing
- Performance monitoring

**‚è≥ Phase 5 - Polish:** 0% Not Started
- Dark mode theme
- Keyboard shortcuts
- Error handling improvements
- Performance optimization

**Current Focus:** User testing Phase 2 with real Air-Side connection

---

## üõ†Ô∏è COMMON TROUBLESHOOTING

### Git Issues

**Issue: "Git pull has conflicts"**
```bash
# See conflicting files
git status

# For protocol files (CAREFUL!):
# 1. DON'T auto-merge protocol JSON files
# 2. Tell user to manually merge
# 3. Verify both sides' implementations are preserved

# For code files:
# 1. Identify conflict markers <<<< >>>> ====
# 2. Discuss with user which version to keep
# 3. Test after resolving
```

**Issue: "Accidentally committed to wrong branch"**
```bash
# If not pushed yet:
git reset --soft HEAD~1  # Undo commit, keep changes
git stash                # Save changes
git checkout main        # Switch to correct branch
git stash pop            # Restore changes
git commit              # Commit again

# If already pushed: Contact user!
```

### Protocol Issues

**Issue: "Commands not working between platforms"**
```bash
# Debugging steps:
# 1. Check protocol versions match
cat protocol/protocol_v1.0.json | jq '.constants.protocol_version'

# 2. Check command is implemented on both sides
cat protocol/commands.json | jq '.commands."command.name".implemented'

# 3. Check for typos in command names
# 4. Verify JSON syntax is correct
# 5. Check network connectivity (ping the other side)
```

**Issue: "Property validation failing"**
```bash
# Check property definition:
cat protocol/camera_properties.json | jq '.properties."property_name".validation'

# Verify:
# 1. Value is in allowed values list
# 2. Value matches expected type
# 3. Dependencies are satisfied (e.g., WB mode for WB temperature)
# 4. Camera is in correct mode (some properties restricted by mode)
```

---

## üìù SUMMARY - THE GOLDEN RULES

### Universal Rules (All Platforms)

1. üî¥ **ALWAYS ask which platform at session start (NEW!)**
2. üî¥ **ALWAYS use platform prefix in Git commits (NEW!)**
3. üî¥ **ALWAYS include detailed cross-platform instructions in commits (NEW!)**
4. üî¥ **ALWAYS confirm current Git branch (should be `main`)**
5. üî¥ **ALWAYS read CC_READ_THIS_FIRST.md at session start**
6. üî¥ **ALWAYS verify protocol files are at ~/DPM-V2/protocol/ NOT docs/protocol/**
7. üî¥ **ALWAYS pull latest from Git before starting work**
8. üî¥ **ALWAYS check protocol synchronization (protocol/commands.json + protocol/camera_properties.json)**
9. üî¥ **ALWAYS read appropriate PROGRESS_AND_TODO.md**
10. üî¥ **ALWAYS update PROGRESS_AND_TODO.md after significant changes**
11. üî¥ **ALWAYS commit regularly (every 30-60 min)**
12. üî¥ **ALWAYS verify build succeeds before committing**
13. üî¥ **ALWAYS commit before ending session**
14. üî¥ **ALWAYS work incrementally (one thing at a time)**
15. üî¥ **NEVER hard-code camera property values - use ~/DPM-V2/protocol/camera_properties.json**

### Platform-Specific Rules

**Air-Side (C++):**
- üü° **ALWAYS check Sony SDK HTML documentation before implementing camera functions**
- üü° Run valgrind regularly for memory leak detection
- üü° Use smart pointers, avoid raw new/delete
- üü° Check Sony SDK return values
- üü° Test with Docker if applicable
- üü° Use `[AIR]` prefix in all Git commits

**Ground-Side (Android):**
- üü° Follow MVVM architecture pattern
- üü° Use Coroutines for async operations
- üü° Check commented-out methods in NetworkClient.kt
- üü° Test on device/emulator before committing
- üü° Use `[GROUND]` prefix in all Git commits

**WindowsTools (Python):**
- üü° **ONLY modify files in WindowsTools/ directory**
- üü° **ALWAYS chain callbacks, never replace them**
- üü° Follow PEP 8 style guidelines
- üü° Never block GUI thread (use threading.Thread(daemon=True))
- üü° Test application starts before committing
- üü° Use `[WINDOWS]` prefix in all Git commits

---

## üéì FOR NEW CLAUDE CODE INSTANCES

### First Session on This Project:

1. ‚úÖ Read this file (CC_READ_THIS_FIRST.md) - you're doing it!
2. ‚úÖ **ASK USER: Which platform are you working on? (AIR/GROUND/WINDOWS/DOCS)**
3. ‚úÖ Confirm current Git branch (should be `main`)
4. ‚úÖ Identify platform and set context
5. ‚úÖ Read appropriate PROGRESS_AND_TODO.md thoroughly
   - Air-Side: `sbc/docs/PROGRESS_AND_TODO.md`
   - Ground-Side: `android/docs/PROGRESS_AND_TODO.md`
   - WindowsTools: `WindowsTools/PROGRESS_AND_TODO.md`
6. ‚úÖ Skim Project_Summary_and_Action_Plan.md (overview only)
7. ‚úÖ Read protocol documentation (commands.json, camera_properties.json)
8. ‚úÖ Check `git log --oneline -20` (understand recent history)
9. ‚úÖ Identify current phase and next task
10. ‚úÖ **[Air-Side Only]** Bookmark Sony SDK HTML documentation location
11. ‚úÖ Start working!

### Subsequent Sessions:

1. ‚úÖ Read this file (CC_READ_THIS_FIRST.md)
2. ‚úÖ **ASK USER: Which platform are you working on? (AIR/GROUND/WINDOWS/DOCS)**
3. ‚úÖ Confirm current Git branch (should be `main`)
4. ‚úÖ Pull latest from Git
5. ‚úÖ Check protocol synchronization
6. ‚úÖ Read appropriate PROGRESS_AND_TODO.md
7. ‚úÖ Check `git status` and `git log --oneline -5`
8. ‚úÖ Continue work

---

## ‚úÖ SESSION END CHECKLIST

**Before ending EVERY work session, verify:**

- [ ] Platform was identified at session start
- [ ] All Git commits use correct `[PLATFORM]` prefix
- [ ] Cross-platform commits include detailed instructions for other platform
- [ ] Current branch is `main`
- [ ] PROGRESS_AND_TODO.md updated with today's work
- [ ] All task checkboxes reflect reality
- [ ] Completion percentages updated
- [ ] Visual progress bars updated (if applicable)
- [ ] "Last Updated" timestamp is current
- [ ] Issue Tracker reflects current bugs/blockers
- [ ] Protocol JSON files updated if implemented commands/properties
- [ ] All code changes are committed with `[PLATFORM][TYPE]` format
- [ ] All commits have descriptive messages with implementation details
- [ ] All commits pushed to origin/main
- [ ] Build succeeds (make/gradle/python)
- [ ] No compiler errors or unresolved warnings
- [ ] Memory leaks checked (air-side with valgrind)
- [ ] No orphaned documentation
- [ ] No [WIP] commits unless work is genuinely incomplete

**If all checked: You're good! üéâ**

---

**Document Status:** ‚úÖ Active - v2.6 with Cross-Platform Commit Message Requirements
**Version:** 2.6 - Cross-platform implementation instructions + all v2.5 features
**Last Updated:** October 31, 2025
**Location:** Project root (DPM-V2/docs/CC_READ_THIS_FIRST.md)
**Maintained By:** Human oversight, enforced by Claude Code

**üî¥ REMEMBER: Read this document at the start of EVERY session! üî¥**
**üî¥ NEW: Always identify your platform (AIR/GROUND/WINDOWS/DOCS) first! üî¥**
**üî¥ NEW: Always use [PLATFORM][TYPE] in Git commits! üî¥**
**üî¥ NEW: Always confirm Git branch is `main` before starting! üî¥**
**üî¥ NEW: Cross-platform commits MUST include detailed instructions for other platform! üî¥**